const z=B("end"),P=B("start");function B(e){return o;function o(n){const i=n&&n.position&&n.position[e]||{};if(typeof i.line=="number"&&i.line>0&&typeof i.column=="number"&&i.column>0)return{line:i.line,column:i.column,offset:typeof i.offset=="number"&&i.offset>-1?i.offset:void 0}}}function Y(e){const o=P(e),n=z(e);if(o&&n)return{start:o,end:n}}const M=-1,E=0,m=1,w=2,S=3,I=4,O=5,d=6,j=7,A=8,T=typeof self=="object"?self:globalThis,C=(e,o)=>{const n=(s,u)=>(e.set(u,s),s),i=s=>{if(e.has(s))return e.get(s);const[u,t]=o[s];switch(u){case E:case M:return n(t,s);case m:{const r=n([],s);for(const c of t)r.push(i(c));return r}case w:{const r=n({},s);for(const[c,g]of t)r[i(c)]=i(g);return r}case S:return n(new Date(t),s);case I:{const{source:r,flags:c}=t;return n(new RegExp(r,c),s)}case O:{const r=n(new Map,s);for(const[c,g]of t)r.set(i(c),i(g));return r}case d:{const r=n(new Set,s);for(const c of t)r.add(i(c));return r}case j:{const{name:r,message:c}=t;return n(new T[r](c),s)}case A:return n(BigInt(t),s);case"BigInt":return n(Object(BigInt(t)),s)}return n(new T[u](t),s)};return i},k=e=>C(new Map,e)(0),y="",{toString:D}={},{keys:N}=Object,b=e=>{const o=typeof e;if(o!=="object"||!e)return[E,o];const n=D.call(e).slice(8,-1);switch(n){case"Array":return[m,y];case"Object":return[w,y];case"Date":return[S,y];case"RegExp":return[I,y];case"Map":return[O,y];case"Set":return[d,y]}return n.includes("Array")?[m,n]:n.includes("Error")?[j,n]:[w,n]},h=([e,o])=>e===E&&(o==="function"||o==="symbol"),J=(e,o,n,i)=>{const s=(t,r)=>{const c=i.push(t)-1;return n.set(r,c),c},u=t=>{if(n.has(t))return n.get(t);let[r,c]=b(t);switch(r){case E:{let f=t;switch(c){case"bigint":r=A,f=t.toString();break;case"function":case"symbol":if(e)throw new TypeError("unable to serialize "+c);f=null;break;case"undefined":return s([M],t)}return s([r,f],t)}case m:{if(c)return s([c,[...t]],t);const f=[],p=s([r,f],t);for(const a of t)f.push(u(a));return p}case w:{if(c)switch(c){case"BigInt":return s([c,t.toString()],t);case"Boolean":case"Number":case"String":return s([c,t.valueOf()],t)}if(o&&"toJSON"in t)return u(t.toJSON());const f=[],p=s([r,f],t);for(const a of N(t))(e||!h(b(t[a])))&&f.push([u(a),u(t[a])]);return p}case S:return s([r,t.toISOString()],t);case I:{const{source:f,flags:p}=t;return s([r,{source:f,flags:p}],t)}case O:{const f=[],p=s([r,f],t);for(const[a,R]of t)(e||!(h(b(a))||h(b(R))))&&f.push([u(a),u(R)]);return p}case d:{const f=[],p=s([r,f],t);for(const a of t)(e||!h(b(a)))&&f.push(u(a));return p}}const{message:g}=t;return s([r,{name:c,message:g}],t)};return u},l=(e,{json:o,lossy:n}={})=>{const i=[];return J(!(o||n),!!o,new Map,i)(e),i},G=typeof structuredClone=="function"?(e,o)=>o&&("json"in o||"lossy"in o)?k(l(e,o)):structuredClone(e):(e,o)=>k(l(e,o));export{z as a,Y as b,P as p,G as s};
